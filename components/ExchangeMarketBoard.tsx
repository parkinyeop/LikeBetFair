import React, { useState, useEffect, useCallback } from 'react';
import { useExchange, type ExchangeOrder } from '../hooks/useExchange';
import { useAuth } from '../contexts/AuthContext';
import { useExchangeContext } from '../contexts/ExchangeContext';
import { getSportKey, getGameInfo } from '../config/sportsMapping';
import { useExchangeGames, ExchangeGame } from '../hooks/useExchangeGames';

interface Order {
  id: string;
  side: 'back' | 'lay';
  price: number;
  amount: number;
}

interface OddsData {
  id: string;
  sport_key: string;
  sport_title: string;
  commence_time: string;
  home_team: string;
  away_team: string;
  bookmakers: Array<{
    key: string;
    title: string;
    last_update: string;
    markets: Array<{
      key: string;
      last_update: string;
      outcomes: Array<{
        name: string;
        price: number;
      }>;
    }>;
  }>;
}

interface MarketSelection {
  team: string;
  back: { price: number; amount: number };
  lay: { price: number; amount: number };
}

interface Market {
  name: string;
  selections: MarketSelection[];
}

interface ExchangeMarketBoardProps {
  selectedCategory?: string;
}

export default function ExchangeMarketBoard({ selectedCategory = "NBA" }: ExchangeMarketBoardProps) {
  const { isLoggedIn } = useAuth();
  const { fetchOrderbook, placeMatchOrder } = useExchange();
  const { games: exchangeGames, loading: gamesLoading, error: gamesError, getGamesByCategory } = useExchangeGames();
  
  const [selectedMarket, setSelectedMarket] = useState(0);
  const [orderbook, setOrderbook] = useState<ExchangeOrder[]>([]);
  const [selectedGame, setSelectedGame] = useState('xxx');
  const [selectedLine, setSelectedLine] = useState(8.5);
  const [oddsData, setOddsData] = useState<OddsData[]>([]);
  const [loading, setLoading] = useState(true);
  const [markets, setMarkets] = useState<Market[]>([]);
  const [selectedGameIndex, setSelectedGameIndex] = useState(0);
  const { setSelectedBet, selectedBet } = useExchangeContext();

  // ÏÑ†ÌÉùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Îî∞Î•∏ Ïä§Ìè¨Ï∏† ÌÇ§ Í≤∞Ï†ï
  const getSportsByCategory = (category: string): string[] => {
    if (category.includes(" > ")) {
      const subCategory = category.split(" > ")[1];
      const sportKey = getSportKey(subCategory);
      return sportKey ? [sportKey] : [];
    }
    
    // Î©îÏù∏ Ïπ¥ÌÖåÍ≥†Î¶¨Ïù∏ Í≤ΩÏö∞ Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Î™®Îì† Ïä§Ìè¨Ï∏† (Ïä§Ìè¨Ï∏†Î∂ÅÏùò Ï†ÑÏ≤¥ Î¶¨Í∑∏)
    const categorySports: Record<string, string[]> = {
      "Ï∂ïÍµ¨": [
        'soccer_korea_kleague1',  // KÎ¶¨Í∑∏
        'soccer_japan_j_league',  // JÎ¶¨Í∑∏
        'soccer_italy_serie_a',   // ÏÑ∏Î¶¨Ïóê A
        'soccer_brazil_campeonato', // Î∏åÎùºÏßà ÏÑ∏Î¶¨Ïóê A
        'soccer_usa_mls',         // MLS
        'soccer_argentina_primera_division', // ÏïÑÎ•¥Ìó®Ìã∞ÎÇò ÌîÑÎ¶¨Î©îÎùº
        'soccer_china_superleague', // Ï§ëÍµ≠ ÏäàÌçºÎ¶¨Í∑∏
        'soccer_spain_primera_division', // ÎùºÎ¶¨Í∞Ä
        'soccer_germany_bundesliga' // Î∂ÑÎç∞Ïä§Î¶¨Í∞Ä
      ],
      "ÏïºÍµ¨": ['baseball_mlb', 'baseball_kbo'],
      "ÎÜçÍµ¨": ['basketball_nba', 'basketball_kbl'],
      "ÎØ∏ÏãùÏ∂ïÍµ¨": ['americanfootball_nfl']
    };
    
    return categorySports[category] || [];
  };

  // ÎçîÎØ∏ Î∞∞ÎãπÏú® Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (ÏÑ†ÌÉùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Îî∞Îùº)
  const generateDummyOdds = (): OddsData[] => {
    const now = new Date();
    const dummyGames: OddsData[] = [];
    
    // ÏÑ†ÌÉùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Îî∞Î•∏ ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    if (selectedCategory.includes("KBO") || selectedCategory === "ÏïºÍµ¨") {
      // KBO Í≤ΩÍ∏∞Îì§ (1Ï£ºÏùº Î≤îÏúÑ)
      const kboTeams = [
        { home: 'SSG Landers', away: 'LG Twins' },
        { home: 'Kia Tigers', away: 'Doosan Bears' },
        { home: 'Samsung Lions', away: 'Hanwha Eagles' },
        { home: 'KT Wiz', away: 'NC Dinos' },
        { home: 'Lotte Giants', away: 'Kiwoom Heroes' }
      ];
      
      kboTeams.forEach((teams, index) => {
        const gameTime = new Date(now.getTime() + (index + 1) * 12 * 60 * 60 * 1000);
        dummyGames.push({
          id: `kbo_${index}`,
          sport_key: 'baseball_kbo',
          sport_title: 'KBO',
          commence_time: gameTime.toISOString(),
          home_team: teams.home,
          away_team: teams.away,
          bookmakers: [{
            key: 'dummy_bookmaker',
            title: 'ÎçîÎØ∏ Î∂ÅÎ©îÏù¥Ïª§',
            last_update: new Date().toISOString(),
            markets: [
              {
                key: 'h2h',
                last_update: new Date().toISOString(),
                outcomes: [
                  { name: teams.home, price: 1.85 + Math.random() * 0.3 },
                  { name: teams.away, price: 1.95 + Math.random() * 0.3 }
                ]
              },
              {
                key: 'totals',
                last_update: new Date().toISOString(),
                outcomes: [
                  { name: 'Over 8.5', price: 1.90 + Math.random() * 0.2 },
                  { name: 'Under 8.5', price: 1.90 + Math.random() * 0.2 }
                ]
              }
            ]
          }]
        });
      });
    }
    
    if (selectedCategory.includes("KÎ¶¨Í∑∏") || selectedCategory === "Ï∂ïÍµ¨") {
      // KÎ¶¨Í∑∏ Í≤ΩÍ∏∞Îì§ (1Ï£ºÏùº Î≤îÏúÑ)
      const kLeagueTeams = [
        { home: 'Ïö∏ÏÇ∞ÌòÑÎåÄ', away: 'ÎåÄÍµ¨ FC' },
        { home: 'Ï†ÑÎ∂ÅÌòÑÎåÄ', away: 'Ìè¨Ìï≠Ïä§Ìã∏Îü¨Ïä§' },
        { home: 'FCÏÑúÏö∏', away: 'ÏàòÏõêÏÇºÏÑ±' },
        { home: 'Ïù∏Ï≤úÏú†ÎÇòÏù¥Ìã∞Îìú', away: 'Í∞ïÏõêFC' },
        { home: 'Ï†úÏ£ºÏú†ÎÇòÏù¥Ìã∞Îìú', away: 'Í¥ëÏ£ºFC' }
      ];
      
      kLeagueTeams.forEach((teams, index) => {
        const gameTime = new Date(now.getTime() + (index + 6) * 12 * 60 * 60 * 1000);
        dummyGames.push({
          id: `kleague_${index}`,
          sport_key: 'soccer_korea_kleague1',
          sport_title: 'KÎ¶¨Í∑∏',
          commence_time: gameTime.toISOString(),
          home_team: teams.home,
          away_team: teams.away,
          bookmakers: [{
            key: 'dummy_bookmaker',
            title: 'ÎçîÎØ∏ Î∂ÅÎ©îÏù¥Ïª§',
            last_update: new Date().toISOString(),
            markets: [
              {
                key: 'h2h',
                last_update: new Date().toISOString(),
                outcomes: [
                  { name: teams.home, price: 1.80 + Math.random() * 0.4 },
                  { name: teams.away, price: 2.20 + Math.random() * 0.4 }
                ]
              },
              {
                key: 'totals',
                last_update: new Date().toISOString(),
                outcomes: [
                  { name: 'Over 2.5', price: 1.85 + Math.random() * 0.2 },
                  { name: 'Under 2.5', price: 1.95 + Math.random() * 0.2 }
                ]
              }
            ]
          }]
        });
      });
    }
    
    if (selectedCategory.includes("NBA") || selectedCategory === "ÎÜçÍµ¨") {
      // NBA Í≤ΩÍ∏∞Îì§ (1Ï£ºÏùº Î≤îÏúÑ)
      const nbaGames = [
        { id: 'nba_lakers_warriors_20250714', home: 'Los Angeles Lakers', away: 'Golden State Warriors' },
        { id: 'nba_celtics_heat_20250714', home: 'Boston Celtics', away: 'Miami Heat' },
        { id: 'nba_bulls_knicks_20250715', home: 'Chicago Bulls', away: 'New York Knicks' },
        { home: 'Dallas Mavericks', away: 'Houston Rockets' },
        { home: 'Phoenix Suns', away: 'Denver Nuggets' }
      ];
      
      nbaGames.forEach((teams, index) => {
        const gameTime = new Date(now.getTime() + (index + 11) * 12 * 60 * 60 * 1000);
        dummyGames.push({
          id: teams.id || `nba_${index}`,
          sport_key: 'basketball_nba',
          sport_title: 'NBA',
          commence_time: gameTime.toISOString(),
          home_team: teams.home,
          away_team: teams.away,
          bookmakers: [{
            key: 'dummy_bookmaker',
            title: 'ÎçîÎØ∏ Î∂ÅÎ©îÏù¥Ïª§',
            last_update: new Date().toISOString(),
            markets: [
              {
                key: 'h2h',
                last_update: new Date().toISOString(),
                outcomes: [
                  { name: teams.home, price: 1.75 + Math.random() * 0.4 },
                  { name: teams.away, price: 2.05 + Math.random() * 0.4 }
                ]
              },
              {
                key: 'totals',
                last_update: new Date().toISOString(),
                outcomes: [
                  { name: 'Over 220.5', price: 1.85 + Math.random() * 0.2 },
                  { name: 'Under 220.5', price: 1.95 + Math.random() * 0.2 }
                ]
              }
            ]
          }]
        });
      });
    }
    
    return dummyGames;
  };

  // Exchange Í≤åÏûÑÏóêÏÑú ÎßàÏºì ÏÉùÏÑ± (Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
  const generateMarketsFromExchangeGame = (game: ExchangeGame): Market[] => {
    console.log('üîß Exchange Í≤åÏûÑÏóêÏÑú ÎßàÏºì ÏÉùÏÑ±:', game);
    return game.availableMarkets.map(market => {
      let selections: MarketSelection[] = [];
      
      if (market.type === 'h2h') {
        // ÏäπÌå® ÎßàÏºì
        selections = [
          {
            team: game.homeTeam,
            back: { price: 1.90, amount: 0 },
            lay: { price: 1.95, amount: 0 }
          },
          {
            team: game.awayTeam,
            back: { price: 1.90, amount: 0 },
            lay: { price: 1.95, amount: 0 }
          }
        ];
      } else if (market.type === 'totals') {
        // Ï¥ùÏ†ê ÎßàÏºì
        selections = [
          {
            team: 'Over 2.5',
            back: { price: 1.85, amount: 0 },
            lay: { price: 1.90, amount: 0 }
          },
          {
            team: 'Under 2.5',
            back: { price: 1.95, amount: 0 },
            lay: { price: 2.00, amount: 0 }
          }
        ];
      } else if (market.type === 'spreads') {
        // Ìï∏ÎîîÏ∫° ÎßàÏºì
        selections = [
          {
            team: `${game.homeTeam} (-0.5)`,
            back: { price: 1.90, amount: 0 },
            lay: { price: 1.95, amount: 0 }
          },
          {
            team: `${game.awayTeam} (+0.5)`,
            back: { price: 1.90, amount: 0 },
            lay: { price: 1.95, amount: 0 }
          }
        ];
      }
      
      return {
        name: market.name,
        selections
      };
    });
  };

  // Î∞∞ÎãπÏú® Îç∞Ïù¥ÌÑ∞Î°úÎ∂ÄÌÑ∞ ÎßàÏºì ÏÉùÏÑ±
  const generateMarketsFromOdds = (gameData: OddsData): Market[] => {
    console.log('ÎßàÏºì ÏÉùÏÑ± ÏãúÏûë:', gameData);
    const newMarkets: Market[] = [];
    
    // Moneyline ÎßàÏºì
    const moneylineMarket = gameData.bookmakers.find(bm => bm.markets.some(m => m.key === 'h2h'));
    if (moneylineMarket) {
      const h2hMarket = moneylineMarket.markets.find(m => m.key === 'h2h');
      if (h2hMarket && h2hMarket.outcomes.length > 0) {
        const selections: MarketSelection[] = h2hMarket.outcomes.map(outcome => ({
          team: outcome.name,
          back: { 
            price: outcome.price, 
            amount: 0 // Í±∞ÎûòÎüâ Ï†ïÎ≥¥ Ï†úÍ±∞
          },
          lay: { 
            price: outcome.price + 0.05, // Í≥†Ï†ïÎêú Î†àÏù¥ Í∞ÄÍ≤© Ï∞®Ïù¥
            amount: 0 // Í±∞ÎûòÎüâ Ï†ïÎ≥¥ Ï†úÍ±∞
          }
        }));
        
        newMarkets.push({
          name: 'ÏäπÌå®',
          selections
        });
        console.log('ÏäπÌå® ÎßàÏºì ÏÉùÏÑ±Îê®');
      }
    }

    // Totals ÎßàÏºì
    const totalsMarket = gameData.bookmakers.find(bm => bm.markets.some(m => m.key === 'totals'));
    if (totalsMarket) {
      const totals = totalsMarket.markets.find(m => m.key === 'totals');
      if (totals && totals.outcomes.length > 0) {
        const selections: MarketSelection[] = totals.outcomes.map(outcome => ({
          team: outcome.name,
          back: { 
            price: outcome.price, 
            amount: 0 // Í±∞ÎûòÎüâ Ï†ïÎ≥¥ Ï†úÍ±∞
          },
          lay: { 
            price: outcome.price + 0.05, // Í≥†Ï†ïÎêú Î†àÏù¥ Í∞ÄÍ≤© Ï∞®Ïù¥
            amount: 0 // Í±∞ÎûòÎüâ Ï†ïÎ≥¥ Ï†úÍ±∞
          }
        }));
        
        newMarkets.push({
          name: 'Ï¥ùÏ†ê',
          selections
        });
        console.log('Ï¥ùÏ†ê ÎßàÏºì ÏÉùÏÑ±Îê®');
      }
    }

    // Spread ÎßàÏºì
    const spreadMarket = gameData.bookmakers.find(bm => bm.markets.some(m => m.key === 'spreads'));
    if (spreadMarket) {
      const spreads = spreadMarket.markets.find(m => m.key === 'spreads');
      if (spreads && spreads.outcomes.length > 0) {
        const selections: MarketSelection[] = spreads.outcomes.map(outcome => ({
          team: outcome.name,
          back: { 
            price: outcome.price, 
            amount: 0 // Í±∞ÎûòÎüâ Ï†ïÎ≥¥ Ï†úÍ±∞
          },
          lay: { 
            price: outcome.price + 0.05, // Í≥†Ï†ïÎêú Î†àÏù¥ Í∞ÄÍ≤© Ï∞®Ïù¥
            amount: 0 // Í±∞ÎûòÎüâ Ï†ïÎ≥¥ Ï†úÍ±∞
          }
        }));
        
        newMarkets.push({
          name: 'Ìï∏ÎîîÏ∫°',
          selections
        });
        console.log('Ìï∏ÎîîÏ∫° ÎßàÏºì ÏÉùÏÑ±Îê®');
      }
    }

    console.log('ÏµúÏ¢Ö ÏÉùÏÑ±Îêú ÎßàÏºìÎì§:', newMarkets);
    return newMarkets;
  };

  // ÎçîÎØ∏ Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
  const generateDummyOrderbook = (game: OddsData): ExchangeOrder[] => {
    const dummyOrders: ExchangeOrder[] = [];
    
    // Back Ï£ºÎ¨∏Îì§ (Îçî ÎÇÆÏùÄ Í∞ÄÍ≤©Î∂ÄÌÑ∞)
    for (let i = 0; i < 5; i++) {
      dummyOrders.push({
        id: i + 1,
        userId: 1,
        gameId: game.id,
        market: 'totals',
        line: 8.5,
        side: 'back',
        price: 1.80 - (i * 0.05),
        amount: Math.floor(Math.random() * 50000) + 10000,
        status: 'open',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
    }
    
    // Lay Ï£ºÎ¨∏Îì§ (Îçî ÎÜíÏùÄ Í∞ÄÍ≤©Î∂ÄÌÑ∞)
    for (let i = 0; i < 5; i++) {
      dummyOrders.push({
        id: i + 6,
        userId: 2,
        gameId: game.id,
        market: 'totals',
        line: 8.5,
        side: 'lay',
        price: 1.90 + (i * 0.05),
        amount: Math.floor(Math.random() * 50000) + 10000,
        status: 'open',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
    }
    
    // Í∞ÄÍ≤©ÏàúÏúºÎ°ú Ï†ïÎ†¨ (BackÏùÄ ÎÇ¥Î¶ºÏ∞®Ïàú, LayÎäî Ïò§Î¶ÑÏ∞®Ïàú)
    return dummyOrders.sort((a, b) => {
      if (a.side === 'back' && b.side === 'back') {
        return b.price - a.price; // BackÏùÄ ÎÜíÏùÄ Í∞ÄÍ≤©Ïù¥ ÏúÑÎ°ú
      } else if (a.side === 'lay' && b.side === 'lay') {
        return a.price - b.price; // LayÎäî ÎÇÆÏùÄ Í∞ÄÍ≤©Ïù¥ ÏúÑÎ°ú
      } else {
        return a.side === 'back' ? -1 : 1; // BackÏù¥ LayÎ≥¥Îã§ ÏúÑÎ°ú
      }
    });
  };

  // Exchange Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
  useEffect(() => {
    if (!gamesLoading && exchangeGames.length > 0) {
      console.log('üéÆ Exchange Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ Î°úÎìú:', exchangeGames.length, 'Í∞ú');
      
      // Exchange Í≤åÏûÑÏùÑ OddsData ÌòïÌÉúÎ°ú Î≥ÄÌôò
      const convertedGames: OddsData[] = exchangeGames.map(game => ({
        id: game.id,
        sport_key: game.sportKey,
        sport_title: game.league,
        commence_time: game.commenceTime,
        home_team: game.homeTeam,
        away_team: game.awayTeam,
        bookmakers: [{
          key: 'exchange',
          title: 'Exchange',
          last_update: new Date().toISOString(),
          markets: game.availableMarkets.map(market => ({
            key: market.type,
            last_update: new Date().toISOString(),
            outcomes: market.selections || []
          }))
        }]
      }));
      
      setOddsData(convertedGames);
      setLoading(false);
      
      // Ï≤´ Î≤àÏß∏ Í≤ΩÍ∏∞Î°ú ÎßàÏºì ÏÉùÏÑ±
      if (convertedGames.length > 0) {
        const firstGameMarkets = generateMarketsFromExchangeGame(exchangeGames[0]);
        console.log('‚úÖ Ï≤´ Î≤àÏß∏ Í≤ΩÍ∏∞ ÎßàÏºì ÏÑ§Ï†ï:', firstGameMarkets);
        setMarkets(firstGameMarkets);
      }
    } else if (gamesError) {
      console.error('‚ùå Exchange Í≤åÏûÑ Î°úÎìú Ïò§Î•ò:', gamesError);
      setOddsData([]);
      setMarkets([]);
      setLoading(false);
    }
  }, [exchangeGames, gamesLoading, gamesError]);

  // Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú
  useEffect(() => {
    console.log('Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú useEffect Ïã§Ìñâ Ï≤¥ÌÅ¨:', {
      isLoggedIn,
      selectedGameIndex,
      'oddsData[selectedGameIndex]': oddsData[selectedGameIndex],
      'markets[selectedMarket]': markets[selectedMarket],
      markets,
      selectedMarket
    });
    
    if (oddsData[selectedGameIndex] && markets[selectedMarket]) {
      const game = oddsData[selectedGameIndex];
      setSelectedGame(game.id);
      
      console.log('Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÎèÑ:', {
        gameId: game.id,
        market: markets[selectedMarket].name,
        line: selectedLine
      });
      
      // Ïã§Ï†ú Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏ÏôÄÏÑú Ïò§ÎçîÎ∂ÅÏóê Î∞òÏòÅ (ÏÑ†ÌÉùÎêú ÎßàÏºìÎ™Ö ÏÇ¨Ïö©)
      fetchOrderbook(game.id, markets[selectedMarket].name, selectedLine).then((orders) => {
        console.log('Í∞ÄÏ†∏Ïò® Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞:', orders);
        setOrderbook(orders);
      }).catch((error) => {
        console.error('Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
      });
    } else {
      console.log('Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ï°∞Í±¥ Î∂àÎßåÏ°±');
    }
  }, [selectedGameIndex, selectedLine, fetchOrderbook, oddsData, markets, selectedMarket]);

  // Í≤ΩÍ∏∞ ÏÑ†ÌÉù Ïãú ÎßàÏºì ÏóÖÎç∞Ïù¥Ìä∏
  const handleGameSelect = (index: number) => {
    console.log('Í≤ΩÍ∏∞ ÏÑ†ÌÉù:', { index, game: oddsData[index] });
    setSelectedGameIndex(index);
    if (oddsData[index]) {
      const markets = generateMarketsFromOdds(oddsData[index]);
      console.log('ÏÉùÏÑ±Îêú ÎßàÏºìÎì§:', markets);
      setMarkets(markets);
      setSelectedMarket(0);
    }
  };

  // Î∞∞ÌåÖ Î≤ÑÌäº ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handleBetClick = (team: string, price: number, type: 'back' | 'lay', gameId: string, marketName: string) => {
    console.log('üéØ Î≤†ÌåÖ ÏÑ†ÌÉù:', { team, price, type, gameId, marketName });
    setSelectedBet({ team, price, type, gameId, market: marketName });
  };

  // Îß§Ïπò Ï£ºÎ¨∏ Ìï∏Îì§Îü¨
  const handleMatchOrder = useCallback(async (existingOrder: ExchangeOrder) => {
    if (!isLoggedIn) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
      return;
    }

    try {
      // Í∏∞Ï°¥ Ï£ºÎ¨∏Ïùò Î∞òÎåÄÌé∏ÏúºÎ°ú Îß§Ïπò Ï£ºÎ¨∏ ÏÉùÏÑ±
      const oppositeSide: 'back' | 'lay' = existingOrder.side === 'back' ? 'lay' : 'back';
      const matchPrice = existingOrder.price; // Í∏∞Ï°¥ Ï£ºÎ¨∏ Í∞ÄÍ≤©ÏúºÎ°ú Îß§Ïπò
      
      // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Î≤†ÌåÖ Ï†ïÎ≥¥ÏóêÏÑú ÌåÄÎ™Ö Í∞ÄÏ†∏Ïò§Í∏∞
      let selectionName = existingOrder.selection || `${oppositeSide} ${matchPrice}`;
      if (selectedBet && selectedBet.team) {
        selectionName = selectedBet.team;
      }
      
      const orderData = {
        gameId: existingOrder.gameId,
        market: existingOrder.market,
        line: existingOrder.line,
        side: oppositeSide,
        price: matchPrice,
        amount: existingOrder.amount, // Ï†ÑÏï° Îß§Ïπò
        selection: selectionName // ÌåÄÎ™Ö ÎòêÎäî Í∏∞Î≥∏Í∞í
      };

      console.log('üéØ Îß§Ïπò Ï£ºÎ¨∏ Ïã§Ìñâ:', orderData);
      
      const result = await placeMatchOrder(orderData);
      
      if (result.success) {
        alert(`‚úÖ Îß§Ïπò ÏÑ±Í≥µ!\nÎß§ÏπòÎêú Í∏àÏï°: ${result.totalMatched.toLocaleString()}Ïõê\nÎß§Ïπò Í∞úÏàò: ${result.matches}Í∞ú`);
        
        // Ìò∏Í∞ÄÏ∞Ω Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ®
        const gameData = oddsData[selectedGameIndex];
        const marketData = markets[selectedMarket];
        
        if (gameData && marketData) {
          const updatedOrderbook = await fetchOrderbook(gameData.id, marketData.name, selectedLine);
          setOrderbook(updatedOrderbook);
        }
      } else {
        alert('Îß§Ïπò Ïã§Ìå®: ' + (result.error || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'));
      }
    } catch (error) {
      console.error('‚ùå Îß§Ïπò Ï£ºÎ¨∏ Ïò§Î•ò:', error);
      alert('Îß§Ïπò Ï£ºÎ¨∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + (error as Error).message);
    }
  }, [isLoggedIn, placeMatchOrder, oddsData, selectedGameIndex, markets, selectedMarket, selectedLine, fetchOrderbook]);

  if (loading) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Î∞∞ÎãπÏú® Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</p>
        </div>
      </div>
    );
  }

  if (oddsData.length === 0) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="text-center">
          <p className="text-gray-600">1Ï£ºÏùº Ïù¥ÎÇ¥Ïùò ÏòàÏ†ïÎêú Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§.</p>
          <p className="text-sm text-gray-500 mt-2">ÏÑ†ÌÉùÎêú Ïπ¥ÌÖåÍ≥†Î¶¨: {selectedCategory}</p>
        </div>
      </div>
    );
  }

  const currentGame = oddsData[selectedGameIndex];
  const market = markets[selectedMarket];

  return (
    <div className="h-full flex flex-col">
      {/* ÏãúÏû• Î≥¥Îìú - Ï†ÑÏ≤¥ */}
      <div className="bg-white rounded shadow p-6 flex-1 overflow-y-auto">
        <h2 className="text-xl font-bold mb-4">ÏãúÏû• Î≥¥Îìú - {selectedCategory}</h2>
        
        {/* Ìò∏Í∞ÄÏ∞Ω ÏÑπÏÖò Ï∂îÍ∞Ä */}
        {oddsData.length > 0 && currentGame && market && (
          <div className="mb-6 border rounded-lg p-4 bg-gray-50">
            {(() => {
              const gameInfo = getGameInfo(currentGame.id);
              return (
                <>
                  <h3 className="text-lg font-bold mb-3">
                    {gameInfo.displayName !== `Unknown Game (${currentGame.id.substring(0, 8)}...)` ? (
                      <>
                        Ìò∏Í∞ÄÏ∞Ω - {gameInfo.displayName} ({market.name})
                        <div className="text-sm text-gray-500 font-normal mt-1">
                          üìÖ {new Date(gameInfo.gameDate).toLocaleString('ko-KR', {
                            month: 'long',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                          })} | üèÄ {gameInfo.homeTeam} vs {gameInfo.awayTeam}
                        </div>
                      </>
                    ) : (
                      <>
                        Ìò∏Í∞ÄÏ∞Ω - {currentGame.home_team} vs {currentGame.away_team} ({market.name})
                        <div className="text-sm text-gray-500 font-normal mt-1">
                          üìÖ {new Date(currentGame.commence_time).toLocaleString('ko-KR')}
                        </div>
                      </>
                    )}
                  </h3>
                </>
              );
            })()}
            
            {!isLoggedIn ? (
              <div className="text-center py-4">
                <p className="text-gray-500">Î°úÍ∑∏Ïù∏ ÌõÑ Ìò∏Í∞Ä Ï†ïÎ≥¥Î•º ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.</p>
              </div>
            ) : orderbook.length === 0 ? (
              <div className="text-center py-4">
                <p className="text-gray-500">ÌòÑÏû¨ Îì±Î°ùÎêú Ìò∏Í∞ÄÍ∞Ä ÏóÜÏäµÎãàÎã§.</p>
                <p className="text-sm text-gray-400">Ï≤´ Î≤àÏß∏ Ï£ºÎ¨∏ÏùÑ Îì±Î°ùÌï¥Î≥¥ÏÑ∏Ïöî!</p>
              </div>
            ) : (
              <div className="grid grid-cols-2 gap-4">
                {/* Back Ï£ºÎ¨∏Îì§ */}
                <div>
                  <h4 className="text-sm font-semibold text-blue-600 mb-2 text-center">Back (Î≤†ÌåÖ)</h4>
                  <div className="space-y-1">
                    {orderbook
                      .filter(order => order.side === 'back')
                      .sort((a, b) => b.price - a.price) // ÎÜíÏùÄ Í∞ÄÍ≤©Î∂ÄÌÑ∞
                      .map((order) => (
                        <div key={order.id} className="bg-blue-50 border border-blue-200 rounded p-2 text-sm">
                          <div className="flex justify-between items-center mb-1">
                            <span className="font-bold text-blue-700">{order.price?.toFixed(2) || 'N/A'}</span>
                            <span className="text-right text-blue-600">{order.amount?.toLocaleString() || 0}Ïõê</span>
                          </div>
                          <div className="flex justify-center">
                            <button
                              onClick={() => handleMatchOrder(order)}
                              className="px-2 py-1 bg-pink-500 text-white text-xs rounded hover:bg-pink-600 transition-colors"
                            >
                              LayÎ°ú Îß§Ïπò
                            </button>
                          </div>
                        </div>
                      ))}
                  </div>
                </div>
                
                {/* Lay Ï£ºÎ¨∏Îì§ */}
                <div>
                  <h4 className="text-sm font-semibold text-pink-600 mb-2 text-center">Lay (Î†àÏù¥)</h4>
                  <div className="space-y-1">
                    {orderbook
                      .filter(order => order.side === 'lay')
                      .sort((a, b) => a.price - b.price) // ÎÇÆÏùÄ Í∞ÄÍ≤©Î∂ÄÌÑ∞
                      .map((order) => (
                        <div key={order.id} className="bg-pink-50 border border-pink-200 rounded p-2 text-sm">
                          <div className="flex justify-between items-center mb-1">
                            <span className="font-bold text-pink-700">{order.price?.toFixed(2) || 'N/A'}</span>
                            <span className="text-right text-pink-600">{order.amount?.toLocaleString() || 0}Ïõê</span>
                          </div>
                          <div className="flex justify-center">
                            <button
                              onClick={() => handleMatchOrder(order)}
                              className="px-2 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors"
                            >
                              BackÏúºÎ°ú Îß§Ïπò
                            </button>
                          </div>
                        </div>
                      ))}
                  </div>
                </div>
              </div>
            )}
            
            <div className="mt-3 text-xs text-gray-500 text-center">
              {(() => {
                const gameInfo = getGameInfo(currentGame.id);
                return gameInfo.displayName !== `Unknown Game (${currentGame.id.substring(0, 8)}...)` ? (
                  <>ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Í≤ΩÍ∏∞: {gameInfo.displayName} | ÎßàÏºì: {market.name} | ÎùºÏù∏: {selectedLine}</>
                ) : (
                  <>ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Í≤ΩÍ∏∞: {currentGame.id} | ÎßàÏºì: {market.name} | ÎùºÏù∏: {selectedLine}</>
                );
              })()}
            </div>
          </div>
        )}
        
        {oddsData.length > 0 ? (
          <div className="space-y-6">
            {oddsData.map((game, gameIndex) => {
              const gameMarkets = generateMarketsFromOdds(game);
              return (
                <div key={game.id} className="border rounded-lg p-4">
                  <div className="mb-3">
                    <h3 className="text-lg font-bold">
                      {game.home_team} vs {game.away_team}
                    </h3>
                    <div className="text-sm text-gray-600">
                      {new Date(game.commence_time).toLocaleString('ko-KR', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                      })}
                    </div>
                    {/* Í≤ΩÍ∏∞ ÏÑ†ÌÉù Î≤ÑÌäº Ï∂îÍ∞Ä */}
                    <div className="mt-2">
                      <button
                        onClick={() => handleGameSelect(gameIndex)}
                        className={`px-3 py-1 rounded text-sm font-medium ${
                          selectedGameIndex === gameIndex
                            ? 'bg-blue-600 text-white'
                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                        }`}
                      >
                        {selectedGameIndex === gameIndex ? 'ÏÑ†ÌÉùÎê®' : 'Ìò∏Í∞Ä Î≥¥Í∏∞'}
                      </button>
                    </div>
                  </div>
                  
                  {gameMarkets.length > 0 ? (
                    <div className="space-y-4">
                      {gameMarkets.map((market, marketIndex) => (
                        <div key={market.name} className="border rounded p-3">
                          <h4 className="font-semibold mb-2 text-blue-600">{market.name}</h4>
                          <table className="w-full text-center border">
                            <thead>
                              <tr className="bg-gray-100">
                                <th className="py-2">ÌåÄ/ÏÑ†ÌÉù</th>
                                <th className="py-2">Back<br/><span className="text-xs text-gray-400">(Î≤†ÌåÖ)</span></th>
                                <th className="py-2">Lay<br/><span className="text-xs text-gray-400">(Î†àÏù¥)</span></th>
                              </tr>
                            </thead>
                            <tbody>
                              {market.selections.map((sel, i) => (
                                <tr key={sel.team} className="border-t hover:bg-gray-50">
                                  <td className="py-3 font-medium">{sel.team}</td>
                                  <td>
                                    <button 
                                      onClick={() => handleBetClick(sel.team, sel.back.price, 'back', game.id, market.name)}
                                      className={`px-4 py-2 rounded font-bold transition-colors w-full ${
                                        selectedBet && 
                                        selectedBet.team === sel.team && 
                                        selectedBet.type === 'back' &&
                                        selectedBet.gameId === game.id &&
                                        selectedBet.market === market.name
                                          ? 'bg-blue-600 text-white shadow-lg ring-2 ring-blue-300'
                                          : 'bg-blue-100 hover:bg-blue-200 text-blue-700'
                                      }`}
                                    >
                                      <div className="text-lg font-bold">{sel.back?.price?.toFixed(2) || 'N/A'}</div>
                                    </button>
                                  </td>
                                  <td>
                                    <button 
                                      onClick={() => handleBetClick(sel.team, sel.lay.price, 'lay', game.id, market.name)}
                                      className={`px-4 py-2 rounded font-bold transition-colors w-full ${
                                        selectedBet && 
                                        selectedBet.team === sel.team && 
                                        selectedBet.type === 'lay' &&
                                        selectedBet.gameId === game.id &&
                                        selectedBet.market === market.name
                                          ? 'bg-pink-600 text-white shadow-lg ring-2 ring-pink-300'
                                          : 'bg-pink-100 hover:bg-pink-200 text-pink-700'
                                      }`}
                                    >
                                      <div className="text-lg font-bold">{sel.lay?.price?.toFixed(2) || 'N/A'}</div>
                                    </button>
                                  </td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-4">
                      <p className="text-gray-500">Ïù¥ Í≤ΩÍ∏∞Ïóê ÎåÄÌïú Î∞∞ÎãπÏú® Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.</p>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        ) : (
          <div className="text-center py-8">
            <p className="text-gray-500">Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§.</p>
          </div>
        )}
      </div>


    </div>
  );
} 