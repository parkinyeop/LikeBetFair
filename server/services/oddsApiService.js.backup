import axios from 'axios';
import OddsCache from '../models/oddsCacheModel.js';
import sportsConfig from '../config/sportsConfig.js';
import { Op } from 'sequelize';
import { normalizeTeamName, normalizeCategory, normalizeCategoryPair } from '../normalizeUtils.js';
import oddsHistoryService from './oddsHistoryService.js';
import { BETTING_CONFIG } from '../config/centralizedConfig.js';
import { ODDS_API_CONFIG, LOG_LEVELS } from '../config/oddsApiConfig.js';

// í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” sport key ë§¤í•‘
const clientSportKeyMap = {
  // ì¶•êµ¬ (Soccer)
  'Kë¦¬ê·¸': 'soccer_korea_kleague1',
  'Jë¦¬ê·¸': 'soccer_japan_j_league',
  'ì„¸ë¦¬ì— A': 'soccer_italy_serie_a',
  'ë¸Œë¼ì§ˆ ì„¸ë¦¬ì— A': 'soccer_brazil_campeonato',
  'MLS': 'soccer_usa_mls',
  'ì•„ë¥´í—¨í‹°ë‚˜ í”„ë¦¬ë©”ë¼': 'soccer_argentina_primera_division',
  'ì¤‘êµ­ ìŠˆí¼ë¦¬ê·¸': 'soccer_china_superleague',
  'ë¼ë¦¬ê°€': 'soccer_spain_la_liga',
  'ë¶„ë°ìŠ¤ë¦¬ê°€': 'soccer_germany_bundesliga',
  'í”„ë¦¬ë¯¸ì–´ë¦¬ê·¸': 'soccer_epl',
  
  // ë†êµ¬ (Basketball)
  'NBA': 'basketball_nba',
  
  // ì•¼êµ¬ (Baseball)
  'MLB': 'baseball_mlb',
  'KBO': 'baseball_kbo',
  
  // ë¯¸ì‹ì¶•êµ¬ (American Football)
  'NFL': 'americanfootball_nfl'
};

class OddsApiService {
  constructor() {
    this.apiKey = process.env.ODDS_API_KEY;
    this.baseUrl = 'https://api.the-odds-api.com/v4/sports';
    
    // API ì‚¬ìš©ëŸ‰ ì¶”ì  (ì„¤ì • íŒŒì¼ì—ì„œ ê°€ì ¸ì˜´)
    this.apiCallTracker = {
      dailyCalls: 0,
      monthlyCalls: 0,
      lastResetDate: new Date().toDateString(),
      dailyLimit: ODDS_API_CONFIG.RATE_LIMITS.DAILY,
      monthlyLimit: ODDS_API_CONFIG.RATE_LIMITS.MONTHLY,
      currentHourCalls: 0,
      hourlyLimit: ODDS_API_CONFIG.RATE_LIMITS.HOURLY
    };
    
    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
    this.performanceMetrics = {
      totalProcessingTime: 0,
      averageProcessingTime: 0,
      callCount: 0
    };
  }

  // API í˜¸ì¶œëŸ‰ ì¶”ì  ë° ì œí•œ í™•ì¸
  trackApiCall() {
    const today = new Date().toDateString();
    const currentHour = new Date().getHours();
    
    // ë‚ ì§œê°€ ë°”ë€Œë©´ ì¼ì¼ ì¹´ìš´í„° ë¦¬ì…‹
    if (this.apiCallTracker.lastResetDate !== today) {
      this.apiCallTracker.dailyCalls = 0;
      this.apiCallTracker.lastResetDate = today;
      this.apiCallTracker.currentHourCalls = 0;
    }
    
    this.apiCallTracker.dailyCalls++;
    this.apiCallTracker.monthlyCalls++;
    this.apiCallTracker.currentHourCalls++;
    
    console.log(`API Call Tracker: Daily ${this.apiCallTracker.dailyCalls}/${this.apiCallTracker.dailyLimit}, Monthly ${this.apiCallTracker.monthlyCalls}/${this.apiCallTracker.monthlyLimit}`);
  }

  // API í˜¸ì¶œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸ (ê°œì„ ëœ ë²„ì „)
  canMakeApiCall() {
    const { dailyCalls, dailyLimit, monthlyCalls, monthlyLimit, currentHourCalls, hourlyLimit } = this.apiCallTracker;
    
    // ì›”ê°„ í•œë„ 90% ë„ë‹¬ ì‹œ ê²½ê³ 
    if (monthlyCalls >= monthlyLimit * 0.9) {
      console.warn(`ì›”ê°„ API ì‚¬ìš©ëŸ‰ 90% ì´ˆê³¼: ${monthlyCalls}/${monthlyLimit}`);
    }
    
    // ì¼ì¼ í•œë„ 80% ë„ë‹¬ ì‹œ ê²½ê³ 
    if (dailyCalls >= dailyLimit * 0.8) {
      console.warn(`ì¼ì¼ API ì‚¬ìš©ëŸ‰ 80% ì´ˆê³¼: ${dailyCalls}/${dailyLimit}`);
    }
    
    // ì‹¤ì œ ì œí•œ ì ìš©
    if (monthlyCalls >= monthlyLimit) {
      console.error('ì›”ê°„ API í•œë„ ì´ˆê³¼!');
      return false;
    }
    
    if (dailyCalls >= dailyLimit) {
      console.error('ì¼ì¼ API í•œë„ ì´ˆê³¼!');
      return false;
    }
    
    if (currentHourCalls >= hourlyLimit) {
      console.error('ì‹œê°„ë‹¹ API í•œë„ ì´ˆê³¼!');
      return false;
    }
    
    return true;
  }

  // êµ¬ì¡°í™”ëœ ë¡œê¹…
  logApiCall(category, status, details = {}) {
    const logData = {
      timestamp: new Date().toISOString(),
      category,
      status,
      apiCalls: this.apiCallTracker.dailyCalls,
      dailyLimit: this.apiCallTracker.dailyLimit,
      monthlyCalls: this.apiCallTracker.monthlyCalls,
      monthlyLimit: this.apiCallTracker.monthlyLimit,
      ...details
    };
    
    if (status === LOG_LEVELS.ERROR) {
      console.error('[API_ERROR]', JSON.stringify(logData));
    } else if (status === LOG_LEVELS.WARN) {
      console.warn('[API_WARN]', JSON.stringify(logData));
    } else {
      console.log('[API_SUCCESS]', JSON.stringify(logData));
    }
  }

  // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  updatePerformanceMetrics(processingTime) {
    this.performanceMetrics.totalProcessingTime += processingTime;
    this.performanceMetrics.callCount++;
    this.performanceMetrics.averageProcessingTime = 
      this.performanceMetrics.totalProcessingTime / this.performanceMetrics.callCount;
    
    // ì„±ëŠ¥ ì„ê³„ê°’ ì²´í¬
    if (processingTime > ODDS_API_CONFIG.PERFORMANCE_THRESHOLDS.MAX_PROCESSING_TIME) {
      console.error(`ì„±ëŠ¥ ì„ê³„ê°’ ì´ˆê³¼: ${processingTime}ms`);
    } else if (processingTime > ODDS_API_CONFIG.PERFORMANCE_THRESHOLDS.WARNING_PROCESSING_TIME) {
      console.warn(`ì„±ëŠ¥ ê²½ê³ : ${processingTime}ms`);
    }
  }

  // ìœ í‹¸ë¦¬í‹°: ëŒ€ê¸° í•¨ìˆ˜
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // API ì‚¬ìš©ëŸ‰ì— ë”°ë¥¸ ë™ì  ìš°ì„ ìˆœìœ„ ì¡°ì ˆ
  getDynamicPriorityLevel() {
    const { dailyCalls, dailyLimit, monthlyCalls, monthlyLimit } = this.apiCallTracker;
    
    const dailyUsageRate = dailyCalls / dailyLimit;
    const monthlyUsageRate = monthlyCalls / monthlyLimit;
    
    if (dailyUsageRate > 0.8 || monthlyUsageRate > 0.8) {
      this.logApiCall('system', LOG_LEVELS.WARN, { 
        message: 'High API usage detected, switching to high priority only',
        dailyUsageRate,
        monthlyUsageRate
      });
      return 'high';
    } else if (dailyUsageRate > 0.6 || monthlyUsageRate > 0.6) {
      this.logApiCall('system', LOG_LEVELS.INFO, { 
        message: 'Medium API usage detected, switching to medium priority',
        dailyUsageRate,
        monthlyUsageRate
      });
      return 'medium';
    } else {
      return 'low';
    }
  }

  // ğŸ†• ê³µì‹ í‰ê·  ë°°ë‹¹ë¥  ê³„ì‚° (ëª¨ë“  ë¶ë©”ì´ì»¤ì˜ outcomeë³„ í‰ê· )
  calculateAverageOdds(bookmakers) {
    if (!bookmakers || !Array.isArray(bookmakers) || bookmakers.length === 0) {
      return null;
    }

    const officialOdds = {};

    // ëª¨ë“  ë¶ë©”ì´ì»¤ì˜ marketsë¥¼ ìˆœíšŒ
    for (const bookmaker of bookmakers) {
      if (!bookmaker.markets || !Array.isArray(bookmaker.markets)) continue;

      for (const market of bookmaker.markets) {
        const marketKey = market.key; // h2h, totals, spreads ë“±
        if (!market.outcomes || !Array.isArray(market.outcomes)) continue;

        // ê° marketë³„ë¡œ outcome ê·¸ë£¹í™”
        if (!officialOdds[marketKey]) {
          officialOdds[marketKey] = {};
        }

        for (const outcome of market.outcomes) {
          const outcomeKey = outcome.name; // íŒ€ëª…, Over, Under, Draw ë“±
          const point = outcome.point; // í•¸ë””ìº¡, ì–¸ë”/ì˜¤ë²„ ê¸°ì¤€ì 
          
          // pointê°€ ìˆëŠ” ê²½ìš° outcomeKeyì— í¬í•¨ (ì˜ˆ: "Over 2.5", "Under 2.5")
          const finalKey = point !== undefined ? `${outcomeKey} ${point}` : outcomeKey;

          if (!officialOdds[marketKey][finalKey]) {
            officialOdds[marketKey][finalKey] = {
              prices: [],
              averagePrice: 0,
              count: 0
            };
          }

          // ìœ íš¨í•œ ë°°ë‹¹ë¥ ë§Œ ìˆ˜ì§‘
          if (outcome.price && typeof outcome.price === 'number' && outcome.price > 1.0) {
            officialOdds[marketKey][finalKey].prices.push(outcome.price);
            officialOdds[marketKey][finalKey].count++;
          }
        }
      }
    }

    // ê° outcomeë³„ í‰ê·  ë°°ë‹¹ë¥  ê³„ì‚°
    for (const marketKey in officialOdds) {
      for (const outcomeKey in officialOdds[marketKey]) {
        const outcome = officialOdds[marketKey][outcomeKey];
        if (outcome.prices.length > 0) {
          outcome.averagePrice = outcome.prices.reduce((sum, price) => sum + price, 0) / outcome.prices.length;
          // ì†Œìˆ˜ì  3ìë¦¬ê¹Œì§€ ë°˜ì˜¬ë¦¼
          outcome.averagePrice = Math.round(outcome.averagePrice * 1000) / 1000;
        }
        // prices ë°°ì—´ì€ ì œê±° (ìµœì¢… ê²°ê³¼ë§Œ ìœ ì§€)
        delete outcome.prices;
      }
    }

    return officialOdds;
  }

  // ìŠ¤ë§ˆíŠ¸ ìºì‹±: ê²½ê¸° ì‹œì‘ ì‹œê°„ì— ë”°ë¥¸ ìš°ì„ ìˆœìœ„ ê²°ì •
  filterGamesByPriority(games, priorityLevel = 'medium') {
    const now = new Date();
    const oneHour = 60 * 60 * 1000;
    const sixHours = 6 * oneHour;
    const twentyFourHours = 24 * oneHour;
    
    return games.filter(game => {
      const gameTime = new Date(game.commence_time);
      const timeDiff = gameTime.getTime() - now.getTime();
      
      switch (priorityLevel) {
        case 'high':
          // 1ì‹œê°„ ì´ë‚´ ì‹œì‘ ë˜ëŠ” ì§„í–‰ ì¤‘ì¸ ê²½ê¸°
          return timeDiff <= oneHour && timeDiff >= -oneHour;
        case 'medium':
          // 6ì‹œê°„ ì´ë‚´ ì‹œì‘ ì˜ˆì • ê²½ê¸°
          return timeDiff > oneHour && timeDiff <= sixHours;
        case 'low':
          // 24ì‹œê°„ ì´ë‚´ ì‹œì‘ ì˜ˆì • ê²½ê¸°
          return timeDiff > sixHours && timeDiff <= twentyFourHours;
        default:
          return true;
      }
    });
  }

  // í™œì„± ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸ (ë¹„ìš© ì ˆì•½ìš©) - ìŠ¤ë§ˆíŠ¸ ìºì‹± ì ìš©
  async fetchAndCacheOddsForCategories(activeCategories, priorityLevel = 'medium') {
    let totalUpdatedCount = 0;
    let totalNewCount = 0;
    let totalSkippedCount = 0;
    let totalApiCalls = 0;
    
    try {
      this.logApiCall('system', LOG_LEVELS.INFO, { 
        message: 'ë°°ë‹¹ë¥  ì—…ë°ì´íŠ¸ ì‹œì‘',
        priorityLevel,
        activeCategoriesCount: activeCategories.length
      });
      
      // í™œì„± ì¹´í…Œê³ ë¦¬ë§Œ í•„í„°ë§
      const categoriesToUpdate = activeCategories.filter(category => 
        clientSportKeyMap.hasOwnProperty(category)
      );
      
      this.logApiCall('system', LOG_LEVELS.INFO, { 
        message: 'í•„í„°ë§ëœ ì¹´í…Œê³ ë¦¬',
        categories: categoriesToUpdate
      });
      
      // ë°°ì¹˜ ì²˜ë¦¬ë¡œ ë©”ëª¨ë¦¬ ìµœì í™”
      const batchSize = ODDS_API_CONFIG.BATCH_SIZE;
      
      for (let i = 0; i < categoriesToUpdate.length; i += batchSize) {
        const batch = categoriesToUpdate.slice(i, i + batchSize);
        
        // ë°°ì¹˜ë³„ë¡œ ì²˜ë¦¬
        await Promise.allSettled(
          batch.map(category => this.processCategoryOdds(category, priorityLevel))
        );
        
        // ë©”ëª¨ë¦¬ ì •ë¦¬ë¥¼ ìœ„í•œ ì§§ì€ ëŒ€ê¸°
        if (i + batchSize < categoriesToUpdate.length) {
          await this.sleep(1000);
        }
      }

      // ê¸°ì¡´ ë°ì´í„° ì •ë¦¬ (ì„¤ì •ì—ì„œ ê°€ì ¸ì˜´)
      await this.cleanupOldData();
      
      this.logApiCall('system', LOG_LEVELS.INFO, { 
        message: 'ë°°ë‹¹ë¥  ì—…ë°ì´íŠ¸ ì™„ë£Œ',
        totalUpdatedCount,
        totalNewCount,
        totalSkippedCount,
        totalApiCalls
      });
      
      return {
        updatedCount: totalUpdatedCount + totalNewCount,
        newCount: totalNewCount,
        updatedExistingCount: totalUpdatedCount,
        skippedCount: totalSkippedCount,
        apiCalls: totalApiCalls,
        categories: categoriesToUpdate
      };
      
    } catch (error) {
      this.logApiCall('system', LOG_LEVELS.ERROR, { 
        message: 'ë°°ë‹¹ë¥  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨',
        error: error.message
      });
      throw error;
    }
  }

  // ê°œë³„ ì¹´í…Œê³ ë¦¬ ì²˜ë¦¬ (ìƒˆë¡œìš´ ë©”ì„œë“œ)
  async processCategoryOdds(clientCategory, priorityLevel) {
    const startTime = Date.now();
    
    try {
      const sportKey = clientSportKeyMap[clientCategory];
      this.logApiCall(clientCategory, LOG_LEVELS.INFO, { 
        message: 'ì¹´í…Œê³ ë¦¬ ì²˜ë¦¬ ì‹œì‘',
        sportKey,
        priorityLevel
      });
      
      let categoryUpdatedCount = 0;
      let categoryNewCount = 0;
      let categorySkippedCount = 0;
      
      // API í˜¸ì¶œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸ (ê°œì„ ëœ ë²„ì „)
      if (!this.canMakeApiCall()) {
        this.logApiCall(clientCategory, LOG_LEVELS.WARN, { 
          message: 'API ì œí•œìœ¼ë¡œ ì¸í•œ ìŠ¤í‚µ'
        });
        return;
      }

      // ìµœê·¼ 7ì¼ê°„ì˜ ê²½ê¸° ë°°ë‹¹ë¥  ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ê°œì„ ëœ ì—ëŸ¬ ì²˜ë¦¬)
      const oddsResponse = await this.fetchOddsWithRetry(sportKey, clientCategory);
      
      if (!oddsResponse) {
        return;
      }

      // ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ê²Œì„ í•„í„°ë§
      const filteredGames = this.filterGamesByPriority(oddsResponse.data, priorityLevel);
      this.logApiCall(clientCategory, LOG_LEVELS.INFO, { 
        message: 'ê²Œì„ í•„í„°ë§ ì™„ë£Œ',
        totalGames: oddsResponse.data.length,
        filteredGames: filteredGames.length,
        priorityLevel
      });

      // ë°ì´í„° ê²€ì¦ ë° ì €ì¥
      for (const game of filteredGames) {
        if (this.validateOddsData(game)) {
          const result = await this.saveGameOdds(game, clientCategory, sportKey);
          if (result === 'new') {
            categoryNewCount++;
          } else if (result === 'updated') {
            categoryUpdatedCount++;
          } else {
            categorySkippedCount++;
          }
        } else {
          categorySkippedCount++;
        }
      }
      
      const processingTime = Date.now() - startTime;
      this.updatePerformanceMetrics(processingTime);
      
      this.logApiCall(clientCategory, LOG_LEVELS.INFO, { 
        message: 'ì¹´í…Œê³ ë¦¬ ì²˜ë¦¬ ì™„ë£Œ',
        newCount: categoryNewCount,
        updatedCount: categoryUpdatedCount,
        skippedCount: categorySkippedCount,
        processingTime
      });
      
    } catch (error) {
      const processingTime = Date.now() - startTime;
      this.logApiCall(clientCategory, LOG_LEVELS.ERROR, { 
        message: 'ì¹´í…Œê³ ë¦¬ ì²˜ë¦¬ ì‹¤íŒ¨',
        error: error.message,
        processingTime
      });
      throw error;
    }
  }

  // ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ API í˜¸ì¶œ
  async fetchOddsWithRetry(sportKey, clientCategory, retryCount = 0) {
    try {
      const oddsResponse = await axios.get(`${this.baseUrl}/${sportKey}/odds`, {
        params: {
          apiKey: this.apiKey,
          regions: 'us',
          markets: 'h2h,spreads,totals',
          oddsFormat: 'decimal',
          dateFormat: 'iso'
        },
        timeout: ODDS_API_CONFIG.TIMEOUT,
        headers: {
          'User-Agent': 'LikeBetFair/1.0'
        }
      });

      // API í˜¸ì¶œ ì¶”ì 
      this.trackApiCall();
      
      return oddsResponse;
      
    } catch (error) {
      // ì—ëŸ¬ ìœ í˜•ë³„ ì²˜ë¦¬
      if (error.response?.status === 429) {
        this.logApiCall(clientCategory, LOG_LEVELS.ERROR, { 
          message: 'API ìš”ì²­ í•œë„ ì´ˆê³¼',
          retryCount
        });
        
        if (retryCount < ODDS_API_CONFIG.ERROR_HANDLING.MAX_RETRIES) {
          await this.sleep(ODDS_API_CONFIG.ERROR_HANDLING.RATE_LIMIT_RETRY_DELAY);
          return this.fetchOddsWithRetry(sportKey, clientCategory, retryCount + 1);
        }
      } else if (error.response?.status === 401) {
        this.logApiCall(clientCategory, LOG_LEVELS.ERROR, { 
          message: 'API í‚¤ ì¸ì¦ ì‹¤íŒ¨'
        });
        throw error; // ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨
      } else {
        this.logApiCall(clientCategory, LOG_LEVELS.ERROR, { 
          message: 'ë°°ë‹¹ë¥  ì¡°íšŒ ì‹¤íŒ¨',
          error: error.message,
          retryCount
        });
        
        if (retryCount < ODDS_API_CONFIG.ERROR_HANDLING.MAX_RETRIES) {
          await this.sleep(ODDS_API_CONFIG.ERROR_HANDLING.RETRY_DELAY);
          return this.fetchOddsWithRetry(sportKey, clientCategory, retryCount + 1);
        }
      }
      
      return null;
    }
  }

          // API í˜¸ì¶œ ì¶”ì 
          this.trackApiCall();
          totalApiCalls++;

          // ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ê²Œì„ í•„í„°ë§
          const filteredGames = this.filterGamesByPriority(oddsResponse.data, priorityLevel);
          console.log(`Found ${oddsResponse.data.length} total games, ${filteredGames.length} games match priority ${priorityLevel} for ${clientCategory}`);

          // ë°ì´í„° ê²€ì¦ ë° ì €ì¥
          for (const game of filteredGames) {
            if (this.validateOddsData(game)) {
              const mainCategory = this.determineMainCategory(clientCategory);
              const subCategory = this.determineSubCategory(clientCategory);
              
              if (!mainCategory || !subCategory) {
                console.error(`[oddsApiService] mainCategory/subCategory ëˆ„ë½: mainCategory=${mainCategory}, subCategory=${subCategory}, data=`, { mainCategory, subCategory, sportKey, sportTitle: clientCategory, homeTeam: game.home_team, awayTeam: game.away_team, commenceTime: new Date(game.commence_time), bookmakers: game.bookmakers });
                categorySkippedCount++;
                totalSkippedCount++;
                continue;
              }
              
              // ê¸°ì¡´ ë°ì´í„° í™•ì¸
              const existingOdds = await OddsCache.findOne({
                where: {
                  mainCategory,
                  subCategory,
                  homeTeam: game.home_team,
                  awayTeam: game.away_team,
                  commenceTime: new Date(game.commence_time)
                }
              });
              
              const oddsData = {
                mainCategory,
                subCategory,
                sportKey: sportKey,
                sportTitle: clientCategory,
                homeTeam: game.home_team,
                awayTeam: game.away_team,
                commenceTime: new Date(game.commence_time),
                bookmakers: game.bookmakers,
                officialOdds: this.calculateAverageOdds(game.bookmakers), // ğŸ†• ê³µì‹ í‰ê·  ë°°ë‹¹ë¥  ì¶”ê°€
                lastUpdated: new Date()
              };
              
              if (existingOdds) {
                // ê¸°ì¡´ ë°ì´í„° ì—…ë°ì´íŠ¸
                const [updatedCount] = await OddsCache.update(oddsData, {
                  where: { id: existingOdds.id }
                });
                
                if (updatedCount > 0) {
                  categoryUpdatedCount++;
                  totalUpdatedCount++;
                  console.log(`Updated existing odds: ${game.home_team} vs ${game.away_team}`);
                  
                  // ì—…ë°ì´íŠ¸ëœ ë°°ë‹¹ë¥  íˆìŠ¤í† ë¦¬ ì €ì¥
                  try {
                    const updatedOdds = await OddsCache.findByPk(existingOdds.id);
                    if (updatedOdds) {
                      const historyCount = await oddsHistoryService.saveOddsSnapshot(updatedOdds);
                      if (historyCount > 0) {
                        console.log(`[OddsHistory] ${clientCategory} ì—…ë°ì´íŠ¸ íˆìŠ¤í† ë¦¬ ${historyCount}ê°œ ì €ì¥ë¨`);
                      }
                    }
                  } catch (historyError) {
                    console.error(`[OddsHistory] íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨ (${clientCategory}):`, historyError.message);
                    // íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨ê°€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•Šë„ë¡ ê³„ì† ì§„í–‰
                  }
                }
              } else {
                // ìƒˆ ë°ì´í„° ìƒì„±
                const newOdds = await OddsCache.create(oddsData);
                categoryNewCount++;
                totalNewCount++;
                console.log(`Created new odds: ${game.home_team} vs ${game.away_team}`);
                
                // ìƒˆ ë°°ë‹¹ë¥  íˆìŠ¤í† ë¦¬ ì €ì¥
                try {
                  const historyCount = await oddsHistoryService.saveOddsSnapshot(newOdds);
                  if (historyCount > 0) {
                    console.log(`[OddsHistory] ${clientCategory} ìƒˆ íˆìŠ¤í† ë¦¬ ${historyCount}ê°œ ì €ì¥ë¨`);
                  }
                } catch (historyError) {
                  console.error(`[OddsHistory] íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨ (${clientCategory}):`, historyError.message);
                  // íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨ê°€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•Šë„ë¡ ê³„ì† ì§„í–‰
                }
              }
            } else {
              categorySkippedCount++;
              totalSkippedCount++;
            }
          }
          
          console.log(`${clientCategory} odds update summary: ${categoryNewCount} new, ${categoryUpdatedCount} updated, ${categorySkippedCount} skipped`);
          
        } catch (error) {
          console.error(`Error fetching odds for ${clientCategory}:`, error.message);
          // ê°œë³„ ìŠ¤í¬ì¸  ì—ëŸ¬ê°€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•Šë„ë¡ ê³„ì† ì§„í–‰
          continue;
        }
      }

      // ê¸°ì¡´ ë°ì´í„° ì •ë¦¬ (7ì¼ ì´ìƒ ëœ ë°ì´í„° ì‚­ì œ)
      await this.cleanupOldData();
      
      console.log(`Odds update completed for active categories. Total: ${totalNewCount} new, ${totalUpdatedCount} updated, ${totalSkippedCount} skipped, ${totalApiCalls} API calls`);
      
      return {
        updatedCount: totalUpdatedCount + totalNewCount,
        newCount: totalNewCount,
        updatedExistingCount: totalUpdatedCount,
        skippedCount: totalSkippedCount,
        apiCalls: totalApiCalls,
        categories: categoriesToUpdate
      };
      
    } catch (error) {
      console.error('Error fetching and caching odds for active categories:', error);
      throw error;
    }
  }

  // ì „ì²´ ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ë©”ì„œë“œ)
  async fetchAndCacheOdds() {
    try {
      console.log('Starting odds update for all categories...');
      
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  ì¹´í…Œê³ ë¦¬ì— ëŒ€í•´ ê°œë³„ì ìœ¼ë¡œ API í˜¸ì¶œ
      for (const [clientCategory, sportKey] of Object.entries(clientSportKeyMap)) {
        console.log(`Fetching odds for ${clientCategory} (${sportKey})...`);
        
        try {
          // ìµœê·¼ 7ì¼ê°„ì˜ ê²½ê¸° ë°°ë‹¹ë¥  ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (íƒ€ì„ì•„ì›ƒ ë° ì¬ì‹œë„ ë¡œì§ ì¶”ê°€)
          const oddsResponse = await axios.get(`${this.baseUrl}/${sportKey}/odds`, {
            params: {
              apiKey: this.apiKey,
              regions: 'us',
              markets: 'h2h,spreads,totals',
              oddsFormat: 'decimal',
              dateFormat: 'iso'
            },
            timeout: 30000, // 30ì´ˆ íƒ€ì„ì•„ì›ƒ (Render ì„œë²„ìš©)
            headers: {
              'User-Agent': 'LikeBetFair/1.0'
            }
          });

          console.log(`Found ${oddsResponse.data.length} games with odds for ${clientCategory}`);

          // ë°ì´í„° ê²€ì¦ ë° ì €ì¥
          for (const game of oddsResponse.data) {
            if (this.validateOddsData(game)) {
              const mainCategory = this.determineMainCategory(clientCategory);
              const subCategory = this.determineSubCategory(clientCategory);
              
              if (!mainCategory || !subCategory) {
                console.error(`[oddsApiService] mainCategory/subCategory ëˆ„ë½: mainCategory=${mainCategory}, subCategory=${subCategory}, data=`, { mainCategory, subCategory, sportKey, sportTitle: clientCategory, homeTeam: game.home_team, awayTeam: game.away_team, commenceTime: new Date(game.commence_time), bookmakers: game.bookmakers });
                continue;
              }
              
              const [oddsRecord, created] = await OddsCache.upsert({
                mainCategory,
                subCategory,
                sportKey: sportKey,
                sportTitle: clientCategory,
                homeTeam: game.home_team,
                awayTeam: game.away_team,
                commenceTime: new Date(game.commence_time),
                bookmakers: game.bookmakers,
                officialOdds: this.calculateAverageOdds(game.bookmakers), // ğŸ†• ê³µì‹ í‰ê·  ë°°ë‹¹ë¥  ì¶”ê°€
                lastUpdated: new Date()
              }, {
                returning: true
              });

              // ë°°ë‹¹ìœ¨ íˆìŠ¤í† ë¦¬ ì €ì¥ (ìƒˆë¡œ ìƒì„±ë˜ê±°ë‚˜ ì—…ë°ì´íŠ¸ëœ ê²½ìš°)
              if (oddsRecord) {
                try {
                  const historyCount = await oddsHistoryService.saveOddsSnapshot(oddsRecord);
                  if (historyCount > 0) {
                    console.log(`[OddsHistory] ${clientCategory} íˆìŠ¤í† ë¦¬ ${historyCount}ê°œ ì €ì¥ë¨`);
                  }
                } catch (historyError) {
                  console.error(`[OddsHistory] íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨ (${clientCategory}):`, historyError.message);
                  // íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨ê°€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•Šë„ë¡ ê³„ì† ì§„í–‰
                }
              }
            }
          }
        } catch (error) {
          console.error(`Error fetching odds for ${clientCategory}:`, error.message);
          // ê°œë³„ ìŠ¤í¬ì¸  ì—ëŸ¬ê°€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•Šë„ë¡ ê³„ì† ì§„í–‰
          continue;
        }
      }

      // ê¸°ì¡´ ë°ì´í„° ì •ë¦¬ (7ì¼ ì´ìƒ ëœ ë°ì´í„° ì‚­ì œ)
      await this.cleanupOldData();
      
      console.log('Odds successfully updated for all categories');
    } catch (error) {
      console.error('Error fetching and caching odds:', error);
      throw error;
    }
  }

  // sportKeyì—ì„œ mainCategory/subCategory ì§ì ‘ ì¶”ì¶œ (fallback)
  parseMainAndSubFromSportKey(sportKey) {
    if (!sportKey) return { mainCategory: '', subCategory: '' };
    const parts = sportKey.split('_');
    const main = parts[0] || '';
    const sub = parts.slice(1).join('_') || '';
    // normalizeCategoryPairëŠ” mainCategory: ì†Œë¬¸ì, subCategory: ëŒ€ë¬¸ì ë°˜í™˜
    return normalizeCategoryPair(main, sub);
  }

  // ê¸°ì¡´ ë©”ì„œë“œ ë³´ì™„: sportKey ìì²´ë„ í—ˆìš©
  getClientCategoryFromSportKey(sportKey) {
    const reverseMap = {};
    for (const [clientCategory, key] of Object.entries(clientSportKeyMap)) {
      reverseMap[key] = clientCategory;
    }
    // fallback: sportKey ìì²´ ë°˜í™˜
    return reverseMap[sportKey] || sportKey;
  }

  // ê¸°ì¡´ ë©”ì„œë“œ ë³´ì™„: clientCategory ë˜ëŠ” sportKey ëª¨ë‘ í—ˆìš©
  determineMainCategory(clientCategoryOrSportKey) {
    if (clientSportKeyMap[clientCategoryOrSportKey]) {
      // clientCategoryì¼ ë•Œ ê¸°ì¡´ ë°©ì‹
      const sportKey = clientSportKeyMap[clientCategoryOrSportKey];
      const parts = sportKey.split('_');
      const main = parts[0] || '';
      const sub = parts.slice(1).join('_') || '';
      return normalizeCategoryPair(main, sub).mainCategory;
    } else {
      // sportKeyì¼ ë•Œ fallback
      return this.parseMainAndSubFromSportKey(clientCategoryOrSportKey).mainCategory;
    }
  }

  determineSubCategory(clientCategoryOrSportKey) {
    if (clientSportKeyMap[clientCategoryOrSportKey]) {
      const sportKey = clientSportKeyMap[clientCategoryOrSportKey];
      const parts = sportKey.split('_');
      const main = parts[0] || '';
      const sub = parts.slice(1).join('_') || '';
      return normalizeCategoryPair(main, sub).subCategory;
    } else {
      return this.parseMainAndSubFromSportKey(clientCategoryOrSportKey).subCategory;
    }
  }

  validateOddsData(game) {
    // ê¸°ì¡´ ê²€ì¦ + ì¶”ê°€ ê²€ì¦
    if (!game.home_team || !game.away_team || !game.commence_time) {
      this.logApiCall('validation', LOG_LEVELS.ERROR, { 
        message: 'í•„ìˆ˜ í•„ë“œ ëˆ„ë½',
        game: { home_team: game.home_team, away_team: game.away_team, commence_time: game.commence_time }
      });
      return false;
    }

    // íŒ€ëª…ì´ ê°™ì€ ê²½ê¸° ì œì™¸ (ë¹„í˜„ì‹¤ì )
    if (game.home_team === game.away_team) {
      this.logApiCall('validation', LOG_LEVELS.ERROR, { 
        message: 'ê°™ì€ íŒ€ë¼ë¦¬ ê²½ê¸°',
        game: `${game.home_team} vs ${game.away_team}`
      });
      return false;
    }

    // ê²½ê¸° ì‹œê°„ì´ ë¯¸ë˜ë¡œ ë„ˆë¬´ ë¨¼ ê²½ìš° ì œì™¸ (1ë…„ ì´ìƒ)
    const gameTime = new Date(game.commence_time);
    const oneYearFromNow = new Date();
    oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);
    
    if (gameTime > oneYearFromNow) {
      this.logApiCall('validation', LOG_LEVELS.ERROR, { 
        message: 'ë„ˆë¬´ ë¨¼ ë¯¸ë˜ ê²½ê¸°',
        gameTime: game.commence_time
      });
      return false;
    }

    // ë°°ë‹¹ë¥  ë°ì´í„° ê²€ì¦
    if (!game.bookmakers || !Array.isArray(game.bookmakers) || game.bookmakers.length === 0) {
      this.logApiCall('validation', LOG_LEVELS.ERROR, { 
        message: 'ë¶ë©”ì´ì»¤ ë°ì´í„° ì—†ìŒ',
        game: `${game.home_team} vs ${game.away_team}`
      });
      return false;
    }

    // ê° ë¶ë©”ì´ì»¤ì˜ ë°°ë‹¹ë¥  ê²€ì¦
    for (const bookmaker of game.bookmakers) {
      if (!bookmaker.markets || !Array.isArray(bookmaker.markets)) {
        this.logApiCall('validation', LOG_LEVELS.ERROR, { 
          message: 'ë§ˆì¼“ ë°ì´í„° ëˆ„ë½',
          bookmaker: bookmaker.title || 'unknown'
        });
        return false;
      }
      
      for (const market of bookmaker.markets) {
        if (!market.outcomes || !Array.isArray(market.outcomes)) {
          this.logApiCall('validation', LOG_LEVELS.ERROR, { 
            message: 'ê²°ê³¼ ë°ì´í„° ëˆ„ë½',
            market: market.key || 'unknown'
          });
          return false;
        }
        
        // ë°°ë‹¹ë¥  ê°’ ê²€ì¦
        for (const outcome of market.outcomes) {
          if (!outcome.price || typeof outcome.price !== 'number' || outcome.price <= 1.0) {
            this.logApiCall('validation', LOG_LEVELS.ERROR, { 
              message: 'ì˜ëª»ëœ ë°°ë‹¹ë¥ ',
              outcome: outcome.name,
              price: outcome.price
            });
            return false;
          }
        }
      }
    }

    return true;
  }

  async cleanupOldData() {
    try {
      // 7ì¼ ì´ìƒ ëœ ë°ì´í„° ì‚­ì œ
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      
      const deletedCount = await OddsCache.destroy({
        where: {
          commenceTime: {
            [Op.lt]: sevenDaysAgo
          }
        }
      });
      
      if (deletedCount > 0) {
        console.log(`Cleaned up ${deletedCount} old odds records`);
      }
    } catch (error) {
      console.error('Error cleaning up old odds data:', error);
    }
  }

  async getOdds(mainCategory = null, subCategory = null, limit = 100) {
    try {
      const whereClause = {};
      if (mainCategory) whereClause.mainCategory = mainCategory;
      if (subCategory) whereClause.subCategory = subCategory;

      const odds = await OddsCache.findAll({
        where: whereClause,
        order: [['commenceTime', 'ASC']],
        limit
      });
      return odds;
    } catch (error) {
      console.error('Error fetching odds:', error);
      throw error;
    }
  }

  async getOddsById(oddsId) {
    try {
      const odds = await OddsCache.findByPk(oddsId);
      return odds;
    } catch (error) {
      console.error('Error fetching odds:', error);
      throw error;
    }
  }

  async updateOdds(oddsId, updateData) {
    try {
      const odds = await OddsCache.findByPk(oddsId);
      if (!odds) {
        throw new Error('Odds not found');
      }

      await odds.update({
        ...updateData,
        lastUpdated: new Date()
      });

      return odds;
    } catch (error) {
      console.error('Error updating odds:', error);
      throw error;
    }
  }

  // ìƒˆë¡œìš´ ë©”ì„œë“œ: íŠ¹ì • ìŠ¤í¬ì¸ ì˜ ìµœê·¼ ë°°ë‹¹ë¥ ë§Œ ê°€ì ¸ì˜¤ê¸°
  async fetchRecentOdds(clientCategory) {
    try {
      const sportKey = clientSportKeyMap[clientCategory];
      if (!sportKey) {
        throw new Error(`Unknown category: ${clientCategory}`);
      }

      const oddsResponse = await axios.get(`${this.baseUrl}/${sportKey}/odds`, {
        params: {
          apiKey: this.apiKey,
          regions: 'us',
          markets: 'h2h,spreads,totals',
          oddsFormat: 'decimal',
          dateFormat: 'iso'
        }
      });

      return oddsResponse.data;
    } catch (error) {
      console.error(`Error fetching recent odds for ${clientCategory}:`, error);
      throw error;
    }
  }

  // ìƒˆë¡œìš´ ë©”ì„œë“œ: ë°°ë‹¹ë¥  ë°ì´í„°ë² ì´ìŠ¤ í†µê³„
  async getOddsStats() {
    try {
      const stats = await OddsCache.findAll({
        attributes: [
          'mainCategory',
          'subCategory',
          [require('sequelize').fn('COUNT', require('sequelize').col('id')), 'count']
        ],
        group: ['mainCategory', 'subCategory'],
        raw: true
      });

      return stats;
    } catch (error) {
      console.error('Error getting odds stats:', error);
      throw error;
    }
  }

  // ìƒˆë¡œìš´ ë©”ì„œë“œ: API í˜¸ì¶œ ë¹„ìš© ì¶”ì •
  async getApiCostEstimate() {
    try {
      const stats = await this.getOddsStats();
      const totalGames = stats.reduce((sum, stat) => sum + parseInt(stat.count), 0);
      
      // ìƒˆë¡œìš´ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê³„ì‚° (ëª©í‘œ: 18,000íšŒ/ì›”)
      // ë¦¬ê·¸ë³„ ë¶„í¬: ê³ ìš°ì„ ìˆœìœ„ 4ê°œ, ì¤‘ìš°ì„ ìˆœìœ„ 4ê°œ, ì €ìš°ì„ ìˆœìœ„ 5ê°œ
      const highPriorityLeagues = 4;
      const mediumPriorityLeagues = 4; 
      const lowPriorityLeagues = 5;
      
      // ê° ë¦¬ê·¸ë‹¹ í‰ê·  ê²½ê¸° ìˆ˜ (571 / 13 = ì•½ 44ê²½ê¸°)
      const avgGamesPerLeague = Math.round(totalGames / 13);
      
      const dailyApiCalls = Math.round(
        (highPriorityLeagues * 8) + // ê³ ìš°ì„ ìˆœìœ„: 3ì‹œê°„ë§ˆë‹¤ = 8íšŒ/ì¼
        (mediumPriorityLeagues * 4) + // ì¤‘ìš°ì„ ìˆœìœ„: 6ì‹œê°„ë§ˆë‹¤ = 4íšŒ/ì¼  
        (lowPriorityLeagues * 2) // ì €ìš°ì„ ìˆœìœ„: 12ì‹œê°„ë§ˆë‹¤ = 2íšŒ/ì¼
      );
      
      const monthlyApiCalls = dailyApiCalls * 30;
      
      return {
        totalGames,
        leagueDistribution: {
          highPriority: `${highPriorityLeagues} leagues (NBA, MLB, KBO, NFL)`,
          mediumPriority: `${mediumPriorityLeagues} leagues (MLS, Kë¦¬ê·¸, Jë¦¬ê·¸, ì„¸ë¦¬ì—A)`,
          lowPriority: `${lowPriorityLeagues} leagues (ì‹œì¦Œ ì˜¤í”„ ë¦¬ê·¸ë“¤)`
        },
        estimatedApiCalls: {
          daily: dailyApiCalls,
          monthly: monthlyApiCalls,
          costEstimate: `$${(monthlyApiCalls * 0.001).toFixed(2)}/month`,
          targetAchieved: monthlyApiCalls <= 18000 ? 'âœ… ëª©í‘œ ë‹¬ì„±' : 'âŒ ëª©í‘œ ì´ˆê³¼'
        },
        limits: {
          dailyLimit: this.apiCallTracker.dailyLimit,
          monthlyLimit: this.apiCallTracker.monthlyLimit,
          currentUsage: {
            daily: this.apiCallTracker.dailyCalls,
            monthly: this.apiCallTracker.monthlyCalls
          }
        },
        optimization: {
          priorityBasedUpdates: 'Reduces calls by ~65%',
          smartCaching: 'Reduces calls by ~25%',
          dynamicThrottling: 'Prevents overuse automatically',
          totalSavings: `From 25,695 to ${monthlyApiCalls} calls (${Math.round((1 - monthlyApiCalls/25695) * 100)}% reduction)`
        }
      };
    } catch (error) {
      console.error('Error getting API cost estimate:', error);
      throw error;
    }
  }

  // ëˆ„ë½ëœ ë©”ì„œë“œ: ì¹´í…Œê³ ë¦¬ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  async getCategories() {
    try {
      const categories = [];
      
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  ì¹´í…Œê³ ë¦¬ ë°˜í™˜
      for (const [clientCategory, sportKey] of Object.entries(clientSportKeyMap)) {
        const mainCategory = this.determineMainCategory(clientCategory);
        const subCategory = this.determineSubCategory(clientCategory);
        
        categories.push({
          clientCategory,
          sportKey,
          mainCategory,
          subCategory,
          displayName: clientCategory
        });
      }
      
      return categories;
    } catch (error) {
      console.error('Error getting categories:', error);
      throw error;
    }
  }

  // ëˆ„ë½ëœ ë©”ì„œë“œ: ìºì‹œëœ ë°°ë‹¹ë¥  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  async getCachedOdds(sportKey, subCategory = null, limit = 100) {
    try {
      console.log(`Fetching cached odds for sportKey: ${sportKey}, subCategory: ${subCategory}, limit: ${limit}`);
      
      // sportKeyë¥¼ í´ë¼ì´ì–¸íŠ¸ ì¹´í…Œê³ ë¦¬ë¡œ ë³€í™˜
      const clientCategory = this.getClientCategoryFromSportKey(sportKey);
      if (!clientCategory) {
        console.log(`Unknown sportKey: ${sportKey}`);
        return [];
      }
      
      const mainCategory = this.determineMainCategory(clientCategory);
      const actualSubCategory = subCategory || this.determineSubCategory(clientCategory);
      
      console.log(`Mapped to mainCategory: ${mainCategory}, subCategory: ${actualSubCategory}`);
      
      const whereClause = {
        mainCategory: mainCategory,
        subCategory: actualSubCategory
      };
      
      const odds = await OddsCache.findAll({
        where: whereClause,
        order: [['commenceTime', 'ASC']],
        limit: limit
      });
      console.log('[getCachedOdds] ì¿¼ë¦¬ ê²°ê³¼:', odds.length, odds.map(o => ({id: o.id, mainCategory: o.mainCategory, subCategory: o.subCategory, homeTeam: o.homeTeam, awayTeam: o.awayTeam, commenceTime: o.commenceTime})));
      
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ê¸°ëŒ€í•˜ëŠ” í˜•ì‹ìœ¼ë¡œ ë³€í™˜
      const formattedOdds = odds.map(oddsRecord => ({
        id: oddsRecord.id,
        sport: sportKey,
        home_team: oddsRecord.homeTeam,
        away_team: oddsRecord.awayTeam,
        commence_time: oddsRecord.commenceTime,
        bookmakers: oddsRecord.bookmakers, // ë¶ë©”ì´ì»¤ ì •ë³´ í¬í•¨
        officialOdds: oddsRecord.officialOdds, // ê³µì‹ í‰ê·  ë°°ë‹¹ë¥ 
        lastUpdated: oddsRecord.lastUpdated
      }));
      
      return formattedOdds;
    } catch (error) {
      console.error('Error fetching cached odds:', error);
      throw error;
    }
  }

  // OddsCache ì €ì¥/ì—…ë°ì´íŠ¸ ì‹œ ì •ê·œí™” ì ìš© ì˜ˆì‹œ (insert, upsert, update ë“± ëª¨ë“  ì €ì¥ ì§€ì ì— ì ìš© í•„ìš”)
  async upsertOddsCache(data) {
    // data: { mainCategory, subCategory, ... }
    const { mainCategory, subCategory } = normalizeCategoryPair(data.mainCategory, data.subCategory);
    const saveData = { ...data, mainCategory, subCategory };
    if (!mainCategory || !subCategory) {
      console.error(`[oddsApiService] mainCategory/subCategory ëˆ„ë½: mainCategory=${mainCategory}, subCategory=${subCategory}, data=`, data);
      return; // ì €ì¥ skip
    }
    return OddsCache.upsert(saveData);
  }

  // OddsCache í…Œì´ë¸”ì˜ ì´ ë ˆì½”ë“œ ìˆ˜ ë°˜í™˜
  async getOddsCount() {
    try {
      const count = await OddsCache.count();
      return count;
    } catch (error) {
      console.error('[OddsApiService] getOddsCount ì˜¤ë¥˜:', error);
      throw error;
    }
  }
}

const oddsApiService = new OddsApiService();
export default oddsApiService; 